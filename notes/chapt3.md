## Kepler架构的3个重要创新：
1. **强化的SM**
2. **动态并行**：允许GPU动态启动新的网格，即任一内核都能启动(调用)其他的内核。使得GPU能够启动嵌套内核，消除了与CPU通信的需求。
![动态并行](./imgs/动态并行.png)
3. **Hyper-Q技术**：增加了更多的CPU与GPU之间的同步硬件连接，确保CPU核心能够在GPU上同时运行更多的任务(减少CPU的限制时间)。  Fermi GPU依赖一个单一的硬件工作队列来从CPU到GPU间传送任务，可能会导致单个任务阻塞队列后面所有任务。 如下图
![Hyper-Q](./imgs/Hyper-Q.png)


## 三种常见的限制内核能的因素
1. **存储带宽**
2. **计算资源**
3. **指令和内存延迟**

# 3.2 线程束执行的本质

## 3.2.1 线程束和线程块
从逻辑角度来看：线程块是线程的集合，可以被组织为一维、二维、三维布局。  <br>
从硬件角度来看：线程块是一维线程束的集合。在线程块中线程被组织成一维布局，每32个连续线程组成一个线程束。

## 3.2.2 线程束分化
同一线程束的线程执行不同指令，被称为线程束分化。 <br>
当线程束的线程产生分化时，线程束将连续执行每一个分支路径，并且禁用不执行这一路径的线程。 <br>
线程束分化只发生在同一线程束中。

## 3.2.3 资源分配
1. 线程束的本地执行上下文：程序计数器、寄存器、共享内存。 <br>
2. **由SM处理的每个线程束的执行上下文，在整个线程束的生存期中都保存在芯片内。因此从一个执行上下文切换到另一个执行上下文没有损失。** <br>
3. 同时存在于一个SM中的线程块和线程束的数量取决于SM中可用的且内核所需的**寄存器**和**共享内存**的数量。

当计算资源已分配给线程块时，线程块被称为**活跃的块**，包含的线程束被称为**活跃的线程束**。 活跃的线程束可以进一步分为：
1. 选定的线程束：被调度到执行单元执行的线程束
2. 符合条件的线程束：准备执行但尚未执行
3. 阻塞的线程束：没有做好执行的准备

同时满足以下两个条件则线程束符合执行条件：
1. 32个CUDA核心可用于执行
2. 当前指令中所有的参数都已就绪


## 3.2.6 同步
两个级别的同步：
1. 系统级：等待主机和设备完成所有的工作。 cudaDeviceSynchronize(void)
2. 块级：在设备执行过程中等待一个**线程块**中所有线程到达同一点。 __syncthreads(void)
